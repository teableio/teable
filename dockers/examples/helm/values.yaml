# The ingress setting is required for Teable
# Some reasons:
# 1. For convenience, we will include the full url address in the return value of the table data api request, So the application must know the exposed host
# 2. The full address should also be included in the email notification
# 3. The attachment management upload service also requires the full storage service access path
# 4. The spreadsheet copy function can be used only when the https service is enabled see (https://developer.mozilla.org/en-US/docs/Web/API/Clipboard)
ingress:
  tls: true
  enabled: true
  hostname: null

config:
  # config this to enable email sending
  mail:
    host: null
    port: null
    secure: true
    sender: teable.localhost
    senderName: Teable
    auth:
      username: null
      password: null

  storage:
    # The URL of the attachment files server. example: https://storage.teable.example.com
    # leave this empty to use the same value as `origin`

    # currently only supports minio
    provider: null

  # leave all the following values empty to generate random values (recommend)
  jwtSecret: null
  sessionSecret: null

  # the key and iv for encrypting, The value is an ascII character string of 16 characters
  # leave all the following values empty to generate random values (recommend)
  # These two values determine the logic generated by the API Access Token, leave them unchanged after data migration
  accessToken:
    key: null
    iv: null

  redisDb: 0

minio:
  auth:
    existingSecret: teable-secret
    rootUserSecretKey: minio-user
    rootPasswordSecretKey: minio-password
  extraEnvVars:
    - name: MINIO_SERVER_URL
      valueFrom:
        secretKeyRef:
          name: teable-secret
          key: minio-url
  ingress:
    tls: false
    enabled: true
    hostname: null
  apiIngress:
    tls: false
    enabled: true
    hostname: null
  # The default buckets for public and private files
  provisioning:
    enabled: true
    # notice: first is public, second is private, cannot change order
    buckets:
      - name: pub-assets
      - name: pvt-assets
    extraCommands:
      - mc anonymous set download provisioning/pub-assets

postgresql:
  auth:
    username: main
    database: teable
    existingSecret: teable-secret
    secretKeys:
      userPasswordKey: database-user-password
      adminPasswordKey: database-admin-password
      replicationPasswordKey: database-replication-password
  persistence:
    enabled: true

redis:
  architecture: standalone
  auth:
    existingSecret: teable-secret
    secretKeys:
      userPasswordKey: redis-password

## @section Global parameters
## @param replicaCount represents the number of pods that will be created for the application
## Set 'replicaCount' to a specific integer value to define the required number of replicas
## Higher values increase the system's ability to handle traffic and provide redundancy
## *NOTE*: Increasing 'replicaCount' may impact system resource usage
replicaCount: 1
## @param nameOverride represents the name that should override the default naming of the application
## Leave 'nameOverride' as an empty string to keep the default naming
## Assign a specific string value to 'nameOverride' to define the required name for the application
nameOverride: ""
## @param fullnameOverride represents the full name that should override the default full naming of the application
## Leave 'fullnameOverride' as an empty string to keep the default full naming
## Assign a specific string value to 'fullnameOverride' to define the required full name for the application
fullnameOverride: ""

## @param nodeSelector is a dictionary that adds scheduling constraints to the pods of the application. These constraints can specify the properties of the desired host of the pods.
## The format for nodeSelector should be: 'LABEL: value'
## Any number of labels can be added to this object.
## To add a label, simply include a new line in the 'nodeSelector: {}' block,
## with the key-value pair representing the label and its corresponding value. The application pods will be scheduled on nodes that match these labels.

nodeSelector: {}

## @param tolerations A list of tolerations that can be applied to Pods of the application. Each entry should represent a separate toleration.
## Tolerations are applied to pods in the case where you want the pods to tolerate the effects of taints, which mark a node as 'unschedulable'.
## If a Pod has a Toleration that matches a Node's Taint, the Pod can be scheduled to the tainted Node.
## Each toleration is represented as an object with properties including 'key', 'operator', 'value', 'effect', and 'tolerationSeconds'.
## The 'key' and 'value' properties define the taint that the toleration matches.
## The 'operator' defines the match relationship between the taint and toleration (e.g., 'Equal' or 'Exists').
## The 'effect' property defines the taint effect that is tolerated (e.g., 'NoSchedule', 'PreferNoSchedule', or 'NoExecute').
## The 'tolerationSeconds' property optionally defines how long a pod with such toleration will stay bound to the node after it has been marked for deletion.

tolerations: []

## @param affinity The `affinity` parameter is an object that sets the scheduling constraints on the pods of the application by setting affinity rules. Affinity rules
## allow you to restrict the nodes on which the application pods are scheduled based on several factors such as labels present on the nodes,
## conditions based on the statuses of other pods etc. This can help you ensure that the application pods are scheduled on the nodes that satisfy
## specific conditions. Affinity supports  'nodeAffinity', 'podAffinity', and 'podAntiAffinity' properties.
##
## The `affinity` object should have a valid formatting that follows the Kubernetes affinity rules. If it is left empty (affinity: {}), no affinity
## rules are applied, meaning that the scheduler is free to place the pods on any available node that meets the requirements.
##
## For example, a typical usage of the affinity parameter in production environments might involve spreading the pods of a specific application across
## different nodes to ensure high availability by setting 'podAntiAffinity' rules. Or you might want to confine the pods to a set of nodes with specific
## labels by adding 'nodeAffinity' rules.
affinity: {}


## @param envVars is a dictionary object that can be used to set Environment Variables in the application.
## The format for envVars should be: 'ENV_VARIABLE_NAME: value'
## Any number of environment variables can be added to this object.
## To add an environment variable, simply include a new line in the 'envVars: {}' block,
## with the key-value pair representing the variable name and its corresponding value.
envVars:
  BRAND_NAME: teable
  NEXTJS_DIR: apps/nextjs-app
  NEXT_ENV_IMAGES_ALL_REMOTE: true

## @param podAnnotations provides additional metadata for pods in the form of annotations.
## Annotations are key-value pairs that can be used to provide non-identifying data for pods.
## They can store large amounts of data, such as JSON blobs, and unlike labels, they do not impact the systemâ€™s internal behavior.
## In this case, 'podAnnotations' is an empty object, indicating no annotations have been added to the pods.
## To add an annotation, simply insert a new line within the 'podAnnotations: {}' block with the format 'ANNOTATION_NAME: value'
## This is useful for tools and libraries that operate at the Kubernetes level.
podAnnotations: {}

## @section OCI parameters
## These parameters will change the way of how OCI is fetched
image:
  ## @param image.repository denotes the name of the image repository, in this case 'nginx'
  repository: ghcr.io/teableio/teable
  ## @param image.pullPolicy a Kubernetes directive which describes how to fetch the Docker image
  pullPolicy: IfNotPresent
  #  credentials:
  ## @extra image.credentials.name: A string representing the name of these credentials, which can be any string.
  #    name: foo
  ## @extra image.credentials.registry: The string value representing the domain of the image registry. In this example, "gitlab.com"
  #    registry: "gitlab.com"
  ## @extra image.credentials.username: The string value representing the username for authentication at the mentioned registry
  #    username: "user"
  ## @extra image.credentials.password: The string value representing the password for the mentioned username at the registry
  #    password: "pass"
  ## @param image.tag used to reference a specific image snapshot in the image repository.
  tag: "latest"
  ## @param image.pullSecrets is an array of references to Kubernetes secrets that contain credentials to access private registries.
  pullSecrets: null


## @section Service parameters
## @descriptionStart
## This section defines parameters for the service which exposes the application to the network.
## @descriptionEnd
service:
  ## @param service.type The type of the service. It can be one of the following: ClusterIP, NodePort, LoadBalancer, or ExternalName.
  type: ClusterIP
  ## @param service.port The port on which the service will listen. Here, it is set to 80.
  port: 80
  ## @param service.targetPort The port of the target Pods where the HTTP service is running. Here, it's also set to 80.
  targetPort: 3000
  ## @param service.annotations This is the place to specify additional annotations for the service. Here, it's an empty object,
  ## indicating there are no custom annotations specified for the service.
  annotations: {}

## @section Probe parameters
## @descriptionStart
## This section defines liveness, readiness, and startup probes for Kubernetes.
## Probes allow Kubernetes to check for certain conditions and respond accordingly.
## @descriptionEnd

probes:
  ## @extra probes.liveness The kubelet uses liveness probes to know when to restart a container.
  liveness:
    ## @skip probes.liveness.path
    path: /
  ## @param probes.readiness The kubelet uses readiness probes to know when a container is ready to start accepting traffic.
  ## If the readiness probe fails, the endpoints controller removes the Pod's IP address from the endpoints of all Services that match the Pod.
  readiness: null
  ## @extra probes.startup The kubelet uses startup probes to know when a container application has started.
  ## If such a probe is configured, it disables liveness and readiness checks until it succeeds, making sure those probes don't interfere with the application startup.
  startup:
    ## @skip probes.startup.path
    path: /

## @section Resource parameters
## @descriptionStart
## This configuration block defines the resources requests and limits for the pods in the deployment.
## Kubernetes uses requests for scheduling pods on its nodes, and to ensure fair resource sharing between pods.
## Limits come into play to guarantee a maximum amount of a resource that a pod can consume, preventing it affecting other pods adversely.
## This block has two main components: `limits` and `requests`, each for CPU and memory.
## @descriptionEnd

#resources:
#   limits:
## @extra resources.limits.cpu: The maximum amount of CPU a pod can use. If the CPU use exceeds this limit,
## the system may throttle the processes in the pod. '100m' implies 0.1 of a CPU core.
#     cpu: 100m
## @extra resources.limits.memory: The maximum amount of memory a pod can use. If a pod exceeds this limit,
## it might be terminated. '128Mi' implies 128 Mebibytes of memory.
#     memory: 128Mi
#   requests:
## @extra resources.requests.cpu: The amount of CPU a pod requests upon scheduling. Kubernetes guarantees to allocate this amount of CPU. '100m' implies 0.1 of a CPU core.
#     cpu: 100m
## @extra resources.requests.memory: The amount of memory a pod requests upon scheduling. Kubernetes guarantees to allocate this amount of memory. '128Mi' implies 128 Mebibytes of memory.
#     memory: 128Mi

## @section Autoscaling
## @descriptionStart
## Parameters for enabling and controlling autoscaling of pods based on defined conditions.
## note: these settings only apply when autoscaling is enabled.
## @descriptionEnd
## @param autoscaling.enabled Set this to true to enable autoscaling, and to false to disable it.
## @param autoscaling.minReplicas Defines the minimum number of pods to deploy.
## @param autoscaling.maxReplicas Defines the maximum number of pods which can be deployed.
## @param autoscaling.targetCPUUtilizationPercentage Defines the percentage of CPU utilization that the system should attempt to maintain. When this value is exceeded, the system will scale up.
## @extra autoscaling.targetMemoryUtilizationPercentage Defines the percentage of memory utilization that the system should attempt to maintain. When this value is exceeded, the system will scale up.
##
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
  targetMemoryUtilizationPercentage: 80

## @section Service Account
## @descriptionStart
## This configuration block is used for controlling parameters linked to service account preferences.
## The service account is used by the application in the code to interact with the Kubernetes API.
## @descriptionEnd
## @param serviceAccount.create A boolean field indicating whether a new service account should be created for your deployment (true) or use an existing one (false).
## @param serviceAccount.annotations An empty dictionary to add any additional annotations you may want associated with the service account.
## @param serviceAccount.name The name for the serviceAccount to be created. If not defined, a name is generated using the `fullname` template.
serviceAccount:
  create: false
  annotations: {}
  name: ""

## @section Persistence parameters
## @descriptionStart
## In this section, you can specify where the application will persist data. For this application, all persistent data is stored on a volume.
## @descriptionEnd
## @extra persistence.[volume-name].size Indicates the size of the volume capacity for data persistent storage. It's string type. The format follows the pattern of the kubernetes resource model (integer number + units like Ki, Mi, Gi, Ti, Pi, Ei). In this example, the size is '8Gi' which denotes a volume of 8 Gibibytes.
## @extra persistence.[volume-name].mountPath A string that specifies the path within the container at which the volume should be mounted. In this snippet, '/data' is the directory path inside the container where the volume is mounted.

## @skip persistence
persistence: {}
#   volume-name:
#     size: 8Gi
#     mountPath: /data

migrationJob:
  enabled: true
  imagePullSecrets: []
  image:
    repository: 'ghcr.io/teableio/teable-db-migrate'
    pullPolicy: IfNotPresent
    # Overrides the image tag whose default is the chart appVersion.
    tag: ""
  podAnnotations: {}
  podSecurityContext: {}
  securityContext: {}

  resources:
    limits:
      memory: 512Mi
    requests:
      cpu: 100m

  nodeSelector: {}
  tolerations: []
  affinity: {}
